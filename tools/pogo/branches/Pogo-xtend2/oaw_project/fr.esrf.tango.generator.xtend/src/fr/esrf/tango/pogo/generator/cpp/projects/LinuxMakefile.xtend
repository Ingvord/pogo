package fr.esrf.tango.pogo.generator.cpp.projects

import fr.esrf.tango.pogo.pogoDsl.PogoDeviceClass
import static org.eclipse.xtext.xtend2.lib.ResourceExtensions.*
import static extension fr.esrf.tango.pogo.generator.cpp.global.StringUtils.*
import static extension fr.esrf.tango.pogo.generator.cpp.global.InheritanceUtils.*
import fr.esrf.tango.pogo.pogoDsl.Inheritance
import com.google.inject.Inject


//======================================================
// Define linux Makefile file to be generated
//======================================================
class LinuxMakefile {
	
	@Inject	extension fr.esrf.tango.pogo.generator.cpp.global.StringUtils
	@Inject	extension fr.esrf.tango.pogo.generator.cpp.global.InheritanceUtils

	//======================================================
	// Define Linux Makefile code to be generated
	//======================================================
	def generateLinuxMakefile (PogoDeviceClass cls) '''
		#PROTECTED REGION ID(«cls.name»::Makefile) ENABLED START#
		#=============================================================================
		#
		# file :        Makefile
		#
		# description : Makefile to generate a TANGO device server.
		#
		# project :     
		#
		# $Author:  $
		#
		# $Revision:  $
		#
		# $Log:  $
		#
		#=============================================================================
		#                This file is generated by POGO
		#        (Program Obviously used to Generate tango Object)
		#=============================================================================
		#
		#
		#=============================================================================
		# MAKE_ENV is the path to find common environment to buil project
		#
		MAKE_ENV = «IF cls.preferences.makefileHome.isSet»«cls.preferences.makefileHome»«ELSE»$(TANGO_HOME)«ENDIF»

		#=============================================================================
		# PACKAGE_NAME is the name of the library/device/exe you want to build
		#
		PACKAGE_NAME = «cls.name»
		MAJOR_VERS   = 1
		MINOR_VERS   = 0
		RELEASE      = Release_$(MAJOR_VERS)_$(MINOR_VERS)
		
		# #=============================================================================
		# # RELEASE_TYPE
		# # - DEBUG     : debug symbols - no optimization
		# # - OPTIMIZED : no debug symbols - optimization level set to O2
		# #-----------------------------------------------------------------------------
		RELEASE_TYPE = DEBUG
		
		#=============================================================================
		# OUTPUT_TYPE can be one of the following :
		#   - 'STATIC_LIB' for a static library (.a)
		#   - 'SHARED_LIB' for a dynamic library (.so)
		#   - 'DEVICE' for a device server (will automatically include and link
		#            with Tango dependencies)
		#   - 'SIMPLE_EXE' for an executable with no dependency (for exemple the test tool
		#                of a library with no Tango dependencies)
		#
		OUTPUT_TYPE = DEVICE
		
		#=============================================================================
		# OUTPUT_DIR  is the directory which contains the build result.
		# if not set, the standard location is :
		#	- $HOME/DeviceServers if OUTPUT_TYPE is DEVICE
		#	- ../bin for others
		#
		OUTPUT_DIR = ./bin/$(BIN_DIR)

		«cls.addInheritanceDefinitions»
		
		
		#=============================================================================
		# INC_DIR_USER is the list of all include path needed by your sources
		#   - for a device server, tango dependencies are automatically appended
		#   - '-I ../include' and '-I .' are automatically appended in all cases
		#
		#
		INC_DIR_USER= -I . «cls.addInheritancIncludeFiles»
		
		
		#=============================================================================
		# LIB_DIR_USER is the list of user library directories
		#   - for a device server, tango libraries directories are automatically appended
		#   - '-L ../lib' is automatically appended in all cases
		#
		LIB_DIR_USER=
		
		#=============================================================================
		# LFLAGS_USR is the list of user link flags
		#   - for a device server, tango libraries directories are automatically appended
		#   - '-ldl -lpthread' is automatically appended in all cases
		#
		# !!! ATTENTION !!!
		# Be aware that the order matters. 
		# For example if you must link with libA, and if libA depends itself on libB
		# you must use '-lA -lB' in this order as link flags, otherwise you will get
		# 'undefined reference' errors
		#
		#LFLAGS_USR+=
		
		
		#=============================================================================
		# CXXFLAGS_USR lists the compilation flags specific for your library/device/exe
		# This is the place where to put your compile-time macros using '-Dmy_macro'
		#
		# -DACE_HAS_EXCEPTIONS -D__ACE_INLINE__ for ACE
		#
		#CXXFLAGS_USR+= -Wall
		
		
		#=============================================================================
		# TANGO_REQUIRED 
		# - TRUE  : your project depends on TANGO
		# - FALSE : your project does not depend on TANGO
		#-----------------------------------------------------------------------------
		# - NOTE : if PROJECT_TYPE is set to DEVICE, TANGO will be auto. added
		#-----------------------------------------------------------------------------  
		TANGO_REQUIRED = TRUE
		
		
		
		#=============================================================================
		#	include Standard TANGO compilation options
		#
		include $(MAKE_ENV)/tango.opt
		
		#=============================================================================
		#	POST_PROCESSING: action to be done after normal make.
		#	e.g.:  change executable file name, .....
		#POST_PROCESSING = \
		#	mv bin/$(BIN_DIR)/$(PACKAGE_NAME) bin/$(BIN_DIR)/$(PACKAGE_NAME)_DS
		
		#=============================================================================
		# SVC_OBJS is the list of all objects needed to make the output
		#
		SVC_INCL =  $(PACKAGE_NAME).h $(PACKAGE_NAME)Class.h
		
		
		SVC_OBJS =      \
		            $(OBJDIR)/$(PACKAGE_NAME).o \
		            $(OBJDIR)/$(PACKAGE_NAME)Class.o \
		            $(OBJDIR)/$(PACKAGE_NAME)StateMachine.o \
		            «cls.dynamicAttrObjects»$(OBJDIR)/ClassFactory.o  \
		            $(OBJDIR)/main.o \
		            $(ADDITIONAL_OBJS) 
		
		«cls.addAdditionalObjectFiles»
		
		#=============================================================================
		#	include common targets
		#
		include $(MAKE_ENV)/common_target.opt
		
		
		#PROTECTED REGION END#
	'''

	//=============================================================================
	// Add dynamic attribute util iof any
	//=============================================================================
 	def dynamicAttrObjects(PogoDeviceClass cls) '''
 		«IF cls.dynamicAttributes.size>0»
 			$(OBJDIR)/$(PACKAGE_NAME)DynAttrUtils.o \
 		«ENDIF»
 	'''
 
 
 
 	//=============================================================================
	// Add Additional object files if any (Utils, threads, ...)
	//=============================================================================
 	def addAdditionalObjectFiles(PogoDeviceClass cls) '''
 		«IF cls.additionalFiles.size>0»
			#------------ Object files for additional files ------------
			ADDITIONAL_OBJS = \
				«cls.additionalFiles.buildAdditionalFileListForMakefile("		$(OBJDIR)/", ".o")»
		«ENDIF»
	'''



	//=============================================================================
 	// Define the definition for inherited classes
 	//=============================================================================
	def addInheritanceDefinitions(PogoDeviceClass cls) '''
		«IF cls.hasInheritanceClass»
			#=============================================================================
			# Following are names, pathes and files of the inherited classes used by project
			#
			«FOR Inheritance inheritance : cls.description.inheritances»
				«IF inheritance.isInheritanceClass»
					#------------ Inheritance from «inheritance.classname» class ------------
					«inheritance.classname.toUpperCase()»_CLASS = «inheritance.classname»
					«inheritance.classname.toUpperCase()»_HOME = «inheritance.sourcePath»
				«ENDIF»
			«ENDFOR»
		«ENDIF»
	'''

	//=============================================================================
 	// Add inheritance include files if any
 	//=============================================================================
 	def addInheritancIncludeFiles(PogoDeviceClass cls) '''
	 	«FOR Inheritance inheritance : cls.description.inheritances»
	 		«IF inheritance.isInheritanceClass»\
				-I $(«inheritance.classname.toUpperCase()»_HOME)
			«ENDIF»
 		«ENDFOR»
 	'''


	//=============================================================================
	//	Add inheritance object files if any
	//=============================================================================
	def addInheritancObjectFiles(PogoDeviceClass cls) '''
		«IF cls.hasInheritanceClass»
			«FOR Inheritance inheritance : cls.description.inheritances»
				«IF inheritance.isInheritanceClass» \
		            $(SVC_«inheritance.classname.toUpperCase()»_OBJ)
		        «ENDIF»
			«ENDFOR»
		
			«FOR Inheritance inheritance : cls.description.inheritances»
				«IF inheritance.isInheritanceClass»

					#------------  Object files for «inheritance.classname» class  ------------
					SVC_«inheritance.classname.toUpperCase()»_OBJ = \
							$(OBJDIR)/«inheritance.classname».o \
							$(OBJDIR)/«inheritance.classname»Class.o \
							$(OBJDIR)/«inheritance.classname»StateMachine.o
				«ENDIF»
			«ENDFOR»
		«ENDIF»
	'''
}